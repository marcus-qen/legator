{{define "title"}}Fleet — Legator{{end}}

{{define "header"}}
<div class="fleet-header">
  <div>
    <h1 class="page-title">Fleet</h1>
    <span class="page-meta"><span id="header-total">{{.Summary.Total}}</span> probes · v{{.Version}}</span>
  </div>
  <div class="fleet-header-actions">
    <button type="button" class="btn fleet-header-toggle fleet-tree-toggle" id="toggle-tree">Probes</button>
    <button type="button" class="btn fleet-header-toggle fleet-feed-toggle" id="toggle-feed">Activity</button>
  </div>
</div>
{{end}}

{{define "content"}}
<div class="fleet-layout" id="fleet-layout">
  <aside class="fleet-tree" id="fleet-tree">
    <div class="tree-search">
      <input type="text" placeholder="Filter probes..." class="input tree-filter" id="tree-filter" autocomplete="off">
    </div>
    <div class="tree-groups" id="tree-groups"></div>
    <div class="tree-tags" id="tree-tags"></div>
    <div class="tree-footer">
      <span class="tree-count" id="tree-count">{{.Summary.Total}} probes</span>
      <span class="dot dot-pending" id="sse-dot"></span>
      <span id="sse-status">connecting…</span>
    </div>
  </aside>

  <div class="drag-handle" data-resize="tree-detail"></div>

  <section class="fleet-detail" id="fleet-detail">
    <div class="detail-empty" id="detail-empty">
      <div class="detail-empty-title">Select a probe</div>
      <div class="detail-empty-stats">
        <span><span class="dot dot-online"></span> <strong id="cnt-online">{{.Summary.Online}}</strong> online</span>
        <span><span class="dot dot-offline"></span> <strong id="cnt-offline">{{.Summary.Offline}}</strong> offline</span>
        <span><strong id="cnt-total">{{.Summary.Total}}</strong> total</span>
      </div>
    </div>
  </section>

  <div class="drag-handle" data-resize="detail-feed"></div>

  <aside class="fleet-feed" id="fleet-feed">
    <div class="feed-header">
      <h3 class="panel-title">Activity</h3>
      <span class="feed-count" id="feed-count">0</span>
    </div>
    <div class="feed-list" id="feed">
      <div class="feed-empty muted">Waiting for fleet events…</div>
    </div>
    <div class="feed-footer">
      <a href="/fleet/chat" class="btn btn-primary" style="width:100%;justify-content:center;">Fleet Chat</a>
    </div>
  </aside>
</div>

<div class="fleet-overlay-backdrop" id="fleet-overlay-backdrop"></div>
{{end}}

{{define "scripts"}}
<script>
(() => {
  const MAX_FEED = 200;
  const STATUS_ORDER = ['online', 'degraded', 'offline', 'pending'];
  const state = {
    probes: [],
    selectedProbeId: null,
    filterText: '',
    activeTag: null,
    activeTab: 'system',
    feed: [],
    collapsed: {
      online: false,
      degraded: false,
      offline: false,
      pending: false,
    },
  };

  const refs = {
    treeGroups: document.getElementById('tree-groups'),
    treeTags: document.getElementById('tree-tags'),
    treeFilter: document.getElementById('tree-filter'),
    treeCount: document.getElementById('tree-count'),
    detail: document.getElementById('fleet-detail'),
    feed: document.getElementById('feed'),
    feedCount: document.getElementById('feed-count'),
    sseDot: document.getElementById('sse-dot'),
    sseStatus: document.getElementById('sse-status'),
    cntOnline: document.getElementById('cnt-online'),
    cntOffline: document.getElementById('cnt-offline'),
    cntTotal: document.getElementById('cnt-total'),
    headerTotal: document.getElementById('header-total'),
    toggleTree: document.getElementById('toggle-tree'),
    toggleFeed: document.getElementById('toggle-feed'),
    overlayBackdrop: document.getElementById('fleet-overlay-backdrop'),
  };

  let currentChatProbeId = null;
  let fleetChatWS = null;
  let fleetChatReconnectTimer = null;
  let fleetChatPollTimer = null;
  let chatHistoryLoaded = false;
  let chatThinking = false;
  const chatMessages = [];
  const chatMessageIds = new Set();

  function esc(value) {
    return String(value ?? '')
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function statusClass(status) {
    const normalized = String(status || '').toLowerCase();
    if (normalized === 'online') return 'online';
    if (normalized === 'offline') return 'offline';
    if (normalized === 'degraded') return 'degraded';
    return 'pending';
  }

  function statusLabel(status) {
    return statusClass(status).toUpperCase();
  }

  function summarize(probes) {
    const summary = { online: 0, offline: 0, degraded: 0, total: probes.length };
    probes.forEach((probe) => {
      const normalized = statusClass(probe.status);
      if (normalized === 'online') summary.online += 1;
      else if (normalized === 'offline') summary.offline += 1;
      else if (normalized === 'degraded') summary.degraded += 1;
    });
    return summary;
  }

  function ago(value) {
    if (!value) return '—';
    const ts = new Date(value).getTime();
    if (Number.isNaN(ts)) return '—';
    const seconds = Math.max(0, Math.floor((Date.now() - ts) / 1000));
    if (seconds < 60) return seconds + 's ago';
    if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
    if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
    return Math.floor(seconds / 86400) + 'd ago';
  }

  function elapsed(value) {
    if (!value) return '—';
    const ts = new Date(value).getTime();
    if (Number.isNaN(ts)) return '—';
    let seconds = Math.max(0, Math.floor((Date.now() - ts) / 1000));
    const days = Math.floor(seconds / 86400);
    seconds -= days * 86400;
    const hours = Math.floor(seconds / 3600);
    seconds -= hours * 3600;
    const mins = Math.floor(seconds / 60);
    if (days > 0) return `${days}d ${hours}h`;
    if (hours > 0) return `${hours}h ${mins}m`;
    if (mins > 0) return `${mins}m`;
    return `${seconds}s`;
  }

  function humanBytes(bytes) {
    const value = Number(bytes || 0);
    if (!Number.isFinite(value) || value <= 0) return '0 B';
    const units = ['B', 'KiB', 'MiB', 'GiB', 'TiB'];
    let unit = 0;
    let size = value;
    while (size >= 1024 && unit < units.length - 1) {
      size /= 1024;
      unit += 1;
    }
    return `${size.toFixed(unit === 0 ? 0 : 1)} ${units[unit]}`;
  }

  function eventTypeLabel(type) {
    const normalized = String(type || 'event');
    if (normalized.startsWith('probe.')) return 'probe';
    if (normalized.startsWith('command.')) return 'command';
    if (normalized.startsWith('approval.')) return 'approval';
    return normalized.split('.')[0] || 'event';
  }

  function getServices(probe) {
    return Array.isArray(probe?.inventory?.services) ? probe.inventory.services : [];
  }

  function getPackages(probe) {
    return Array.isArray(probe?.inventory?.packages) ? probe.inventory.packages : [];
  }

  function getInterfaces(probe) {
    return Array.isArray(probe?.inventory?.interfaces) ? probe.inventory.interfaces : [];
  }

  function chatMessageKey(message) {
    if (message && message.id) return `id:${String(message.id)}`;
    const role = String(message?.role || 'assistant').toLowerCase();
    const timestamp = String(message?.timestamp || '');
    const commandId = String(message?.command_id || '');
    const content = String(message?.content || '');
    return `fallback:${role}:${timestamp}:${commandId}:${content}`;
  }

  function normalizeChatMessage(message) {
    if (!message || typeof message !== 'object') return null;
    const roleRaw = String(message.role || 'assistant').toLowerCase();
    const role = ['user', 'assistant', 'system'].includes(roleRaw) ? roleRaw : 'assistant';
    const content = String(message.content || '');
    if (!content.trim()) return null;
    return {
      id: message.id ? String(message.id) : '',
      role,
      content,
      command_id: message.command_id ? String(message.command_id) : '',
      timestamp: message.timestamp ? String(message.timestamp) : '',
    };
  }

  function isChatTabActive() {
    return state.activeTab === 'chat' && state.selectedProbeId && state.selectedProbeId === currentChatProbeId;
  }

  function renderChatMessage(container, message) {
    const row = document.createElement('div');
    row.className = `msg-row ${message.role}`;

    const bubble = document.createElement('div');
    bubble.className = `msg msg-${message.role}`;

    const body = document.createElement('div');
    body.textContent = message.content;
    bubble.appendChild(body);

    if (message.timestamp) {
      const meta = document.createElement('div');
      meta.className = 'chat-meta';
      const date = new Date(message.timestamp);
      meta.textContent = Number.isNaN(date.getTime()) ? message.timestamp : date.toLocaleTimeString();
      bubble.appendChild(meta);
    }

    row.appendChild(bubble);
    container.appendChild(row);
  }

  function scrollFleetChatToBottom() {
    const messages = document.getElementById('fleet-chat-messages');
    if (!messages) return;
    messages.scrollTop = messages.scrollHeight;
  }

  function renderFleetChatMessages() {
    const messages = document.getElementById('fleet-chat-messages');
    if (!messages) return;

    messages.innerHTML = '';

    if (!chatMessages.length) {
      const empty = document.createElement('div');
      empty.className = 'chat-empty';
      empty.textContent = 'Ask this probe anything...';
      messages.appendChild(empty);
    } else {
      chatMessages.forEach((message) => {
        renderChatMessage(messages, message);
      });
    }

    scrollFleetChatToBottom();
  }

  function setFleetChatThinking(value) {
    chatThinking = Boolean(value);
    const typing = document.getElementById('fleet-chat-typing');
    if (!typing) return;
    typing.hidden = !chatThinking;
    if (chatThinking) {
      scrollFleetChatToBottom();
    }
  }

  function autoResizeTextarea(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
  }

  function stopFleetChatPolling() {
    if (!fleetChatPollTimer) return;
    window.clearInterval(fleetChatPollTimer);
    fleetChatPollTimer = null;
  }

  function stopFleetChatReconnect() {
    if (!fleetChatReconnectTimer) return;
    window.clearTimeout(fleetChatReconnectTimer);
    fleetChatReconnectTimer = null;
  }

  function teardownFleetChat(options = {}) {
    const { clear = false } = options;

    stopFleetChatReconnect();
    stopFleetChatPolling();

    if (fleetChatWS) {
      fleetChatWS.__manualClose = true;
      fleetChatWS.close();
      fleetChatWS = null;
    }

    if (clear) {
      chatMessages.length = 0;
      chatMessageIds.clear();
      chatHistoryLoaded = false;
      setFleetChatThinking(false);
    }
  }

  function appendFleetChatMessage(message) {
    const normalized = normalizeChatMessage(message);
    if (!normalized) return false;

    const key = chatMessageKey(normalized);
    if (chatMessageIds.has(key)) return false;

    chatMessageIds.add(key);
    chatMessages.push(normalized);

    if (chatMessages.length > 300) {
      const dropped = chatMessages.shift();
      if (dropped) {
        chatMessageIds.delete(chatMessageKey(dropped));
      }
    }

    if (normalized.role === 'assistant' || normalized.role === 'system') {
      setFleetChatThinking(false);
    }

    if (isChatTabActive()) {
      renderFleetChatMessages();
    }

    return true;
  }

  async function loadFleetChatHistory(probeId) {
    if (!probeId) return;

    const response = await fetch(`/api/v1/probes/${encodeURIComponent(probeId)}/chat?limit=50`, { cache: 'no-store' });
    if (!response.ok) {
      throw new Error(`chat history request failed: ${response.status}`);
    }

    const payload = await response.json();
    const items = Array.isArray(payload) ? payload.slice() : [];
    items
      .sort((a, b) => {
        const ta = new Date(a?.timestamp || 0).getTime();
        const tb = new Date(b?.timestamp || 0).getTime();
        return ta - tb;
      })
      .forEach((message) => {
        appendFleetChatMessage(message);
      });

    chatHistoryLoaded = true;

    if (isChatTabActive()) {
      renderFleetChatMessages();
      setFleetChatThinking(chatThinking);
    }
  }

  function scheduleFleetChatReconnect(probeId) {
    if (!probeId || probeId !== currentChatProbeId) return;
    stopFleetChatReconnect();

    fleetChatReconnectTimer = window.setTimeout(() => {
      fleetChatReconnectTimer = null;
      if (probeId !== currentChatProbeId) return;
      connectFleetChatSocket(probeId);
    }, 3000);
  }

  function startFleetChatPolling(probeId) {
    if (fleetChatPollTimer || !probeId) return;

    fleetChatPollTimer = window.setInterval(() => {
      if (probeId !== currentChatProbeId) {
        stopFleetChatPolling();
        return;
      }

      loadFleetChatHistory(probeId).catch(() => {
        // best effort fallback while websocket reconnects
      });
    }, 5000);
  }

  function connectFleetChatSocket(probeId) {
    if (!probeId || probeId !== currentChatProbeId) return;

    if (fleetChatWS && (fleetChatWS.readyState === WebSocket.OPEN || fleetChatWS.readyState === WebSocket.CONNECTING)) {
      return;
    }

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const socketUrl = `${protocol}//${window.location.host}/ws/chat?probe_id=${encodeURIComponent(probeId)}`;

    let socket;
    try {
      socket = new WebSocket(socketUrl);
    } catch {
      startFleetChatPolling(probeId);
      scheduleFleetChatReconnect(probeId);
      return;
    }

    fleetChatWS = socket;

    socket.onopen = () => {
      if (probeId !== currentChatProbeId) {
        socket.__manualClose = true;
        socket.close();
        return;
      }
      stopFleetChatPolling();
      stopFleetChatReconnect();
    };

    socket.onmessage = (event) => {
      let payload;
      try {
        payload = JSON.parse(event.data);
      } catch {
        return;
      }

      const messages = Array.isArray(payload) ? payload : [payload];
      messages.forEach((item) => appendFleetChatMessage(item));
    };

    socket.onerror = () => {
      // onclose handles reconnect logic
    };

    socket.onclose = () => {
      if (fleetChatWS === socket) {
        fleetChatWS = null;
      }
      if (socket.__manualClose || probeId !== currentChatProbeId) return;
      startFleetChatPolling(probeId);
      scheduleFleetChatReconnect(probeId);
    };
  }

  async function sendFleetChatMessage(probeId, content) {
    const text = String(content || '').trim();
    if (!probeId || !text || probeId !== currentChatProbeId) return;

    setFleetChatThinking(true);

    const canUseSocket = fleetChatWS
      && fleetChatWS.readyState === WebSocket.OPEN
      && probeId === currentChatProbeId;

    if (canUseSocket) {
      try {
        fleetChatWS.send(JSON.stringify({ content: text }));
        window.setTimeout(() => {
          if (probeId === currentChatProbeId) {
            loadFleetChatHistory(probeId).catch(() => {
              // best effort sync in case websocket only emits assistant replies
            });
          }
        }, 800);
        return;
      } catch {
        // fallback to REST below
      }
    }

    const response = await fetch(`/api/v1/probes/${encodeURIComponent(probeId)}/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content: text }),
    });

    if (!response.ok) {
      setFleetChatThinking(false);
      throw new Error(`chat send failed: ${response.status}`);
    }

    const payload = await response.json();
    appendFleetChatMessage(payload);
    await loadFleetChatHistory(probeId);
  }

  function bindFleetChatForm(probeId) {
    const form = document.getElementById('fleet-chat-form');
    const textarea = document.getElementById('fleet-chat-input');
    const submit = form?.querySelector('button[type="submit"]');
    if (!form || !textarea || !submit) return;

    autoResizeTextarea(textarea);

    textarea.addEventListener('input', () => {
      autoResizeTextarea(textarea);
    });

    textarea.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        form.requestSubmit();
      }
    });

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const content = textarea.value.trim();
      if (!content || probeId !== currentChatProbeId) return;

      textarea.value = '';
      autoResizeTextarea(textarea);

      submit.disabled = true;
      try {
        await sendFleetChatMessage(probeId, content);
      } catch {
        setFleetChatThinking(false);
      } finally {
        submit.disabled = false;
        textarea.focus();
      }
    });
  }

  function initFleetChat(probeId) {
    if (!probeId || probeId !== currentChatProbeId) return;

    renderFleetChatMessages();
    setFleetChatThinking(chatThinking);
    bindFleetChatForm(probeId);

    if (!chatHistoryLoaded) {
      loadFleetChatHistory(probeId).catch(() => {
        // best effort
      });
    }

    connectFleetChatSocket(probeId);
  }

  function matchesFilters(probe) {
    const name = String(probe.hostname || '').toLowerCase();
    const hasName = !state.filterText || name.includes(state.filterText);
    const tags = Array.isArray(probe.tags) ? probe.tags : [];
    const hasTag = !state.activeTag || tags.includes(state.activeTag);
    return hasName && hasTag;
  }

  function sortedProbes(input) {
    return input.slice().sort((a, b) => {
      const aName = String(a.hostname || a.id || '').toLowerCase();
      const bName = String(b.hostname || b.id || '').toLowerCase();
      return aName.localeCompare(bName);
    });
  }

  function renderTree() {
    const filtered = sortedProbes(state.probes.filter(matchesFilters));
    const grouped = {
      online: [],
      degraded: [],
      offline: [],
      pending: [],
    };

    filtered.forEach((probe) => {
      grouped[statusClass(probe.status)].push(probe);
    });

    refs.treeGroups.innerHTML = '';

    STATUS_ORDER.forEach((groupName) => {
      const items = grouped[groupName] || [];
      const group = document.createElement('div');
      group.className = 'tree-group';

      const header = document.createElement('button');
      header.type = 'button';
      header.className = 'tree-group-header';
      header.dataset.group = groupName;
      header.dataset.collapsed = state.collapsed[groupName] ? 'true' : 'false';
      header.innerHTML = `
        <span class="tree-chevron">${state.collapsed[groupName] ? '▶' : '▼'}</span>
        <span class="dot dot-${groupName}"></span>
        <span>${groupName[0].toUpperCase() + groupName.slice(1)}</span>
        <span class="tree-count-badge">${items.length}</span>
      `;
      header.addEventListener('click', () => {
        state.collapsed[groupName] = !state.collapsed[groupName];
        renderTree();
      });

      const list = document.createElement('div');
      list.className = 'tree-group-items';
      if (state.collapsed[groupName]) {
        list.style.display = 'none';
      }

      items.forEach((probe) => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'tree-item' + (probe.id === state.selectedProbeId ? ' selected' : '');
        item.dataset.probeId = probe.id;
        item.title = probe.id;
        item.innerHTML = `<span class="tree-hostname">${esc(probe.hostname || probe.id)}</span>`;
        item.addEventListener('click', () => selectProbe(probe.id));
        list.appendChild(item);
      });

      group.append(header, list);
      refs.treeGroups.appendChild(group);
    });

    renderTagFilters();

    const summary = summarize(state.probes);
    refs.treeCount.textContent = `${filtered.length} probes`;
    refs.headerTotal.textContent = String(summary.total);
    refs.cntOnline.textContent = String(summary.online);
    refs.cntOffline.textContent = String(summary.offline);
    refs.cntTotal.textContent = String(summary.total);
  }

  function renderTagFilters() {
    const counts = new Map();
    state.probes.forEach((probe) => {
      (Array.isArray(probe.tags) ? probe.tags : []).forEach((tag) => {
        counts.set(tag, (counts.get(tag) || 0) + 1);
      });
    });

    refs.treeTags.innerHTML = '';

    const title = document.createElement('div');
    title.className = 'tree-tags-title';
    title.textContent = 'Tags';
    refs.treeTags.appendChild(title);

    if (!counts.size) {
      const empty = document.createElement('div');
      empty.className = 'muted tree-tags-empty';
      empty.textContent = 'No tags';
      refs.treeTags.appendChild(empty);
      return;
    }

    const wrap = document.createElement('div');
    wrap.className = 'tree-tag-list';

    Array.from(counts.entries())
      .sort((a, b) => a[0].localeCompare(b[0]))
      .forEach(([tag, count]) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'tree-tag' + (state.activeTag === tag ? ' active' : '');
        button.innerHTML = `<span>${esc(tag)}</span><span class="tree-count-badge">${count}</span>`;
        button.addEventListener('click', () => {
          state.activeTag = state.activeTag === tag ? null : tag;
          renderTree();
        });
        wrap.appendChild(button);
      });

    refs.treeTags.appendChild(wrap);
  }

  function renderTabContent(probe) {
    const inventory = probe.inventory || {};

    if (state.activeTab === 'system') {
      return `
        <dl class="kv-grid detail-kv-grid">
          <dt>Hostname</dt><dd>${esc(probe.hostname || inventory.hostname || '-')}</dd>
          <dt>OS</dt><dd>${esc(probe.os || inventory.os || '-')}</dd>
          <dt>Arch</dt><dd>${esc(probe.arch || inventory.arch || '-')}</dd>
          <dt>Kernel</dt><dd>${esc(inventory.kernel || '-')}</dd>
          <dt>CPUs</dt><dd>${esc(inventory.cpus ?? '-')}</dd>
          <dt>Memory</dt><dd>${humanBytes(inventory.mem_total_bytes)}</dd>
          <dt>Disk</dt><dd>${humanBytes(inventory.disk_total_bytes)}</dd>
        </dl>
      `;
    }

    if (state.activeTab === 'network') {
      const interfaces = getInterfaces(probe);
      if (!interfaces.length) {
        return '<div class="muted detail-empty-panel">No network interfaces reported.</div>';
      }

      return `
        <div class="detail-list detail-list-network">
          ${interfaces.map((net) => `
            <div class="detail-list-row">
              <span>${esc(net.name || '-')}</span>
              <span class="detail-list-mono">${esc(net.mac || '-')}</span>
              <span class="tag tag-${statusClass(net.state || 'pending')}">${esc(String(net.state || 'unknown').toUpperCase())}</span>
            </div>
          `).join('')}
        </div>
      `;
    }

    if (state.activeTab === 'services') {
      const services = getServices(probe);
      if (!services.length) {
        return '<div class="muted detail-empty-panel">No services reported.</div>';
      }

      return `
        <div class="detail-list detail-list-scroll">
          ${services.map((svc) => {
            const name = svc?.name || svc?.service || svc?.unit || String(svc || '-');
            const rawState = String(svc?.state || svc?.status || '').toLowerCase();
            const stateClass = rawState.includes('run') || rawState === 'up' ? 'online' : rawState.includes('fail') || rawState === 'down' ? 'offline' : rawState ? 'degraded' : 'pending';
            const stateText = rawState ? rawState.toUpperCase() : 'UNKNOWN';
            return `
              <div class="detail-list-row">
                <span>${esc(name)}</span>
                <span class="tag tag-${stateClass}">${esc(stateText)}</span>
              </div>
            `;
          }).join('')}
        </div>
      `;
    }

    if (state.activeTab === 'chat') {
      return `
        <div class="detail-chat">
          <div class="chat-messages" id="fleet-chat-messages">
            <div class="chat-empty">Ask this probe anything...</div>
          </div>
          <div class="chat-typing" id="fleet-chat-typing" hidden>Thinking...</div>
          <form class="chat-input-form" id="fleet-chat-form">
            <textarea id="fleet-chat-input" rows="1" placeholder="Ask this probe..." maxlength="4000" autocomplete="off" required></textarea>
            <button type="submit" class="btn btn-primary">Send</button>
          </form>
        </div>
      `;
    }

    const packages = getPackages(probe);
    if (!packages.length) {
      return '<div class="muted detail-empty-panel">No packages reported.</div>';
    }

    return `
      <div class="detail-list detail-list-scroll">
        ${packages.map((pkg) => {
          const name = pkg?.name || pkg?.package || String(pkg || '-');
          const version = pkg?.version || pkg?.ver || pkg?.release || '-';
          return `
            <div class="detail-list-row">
              <span>${esc(name)}</span>
              <span class="detail-list-mono">${esc(version)}</span>
            </div>
          `;
        }).join('')}
      </div>
    `;
  }

  function renderDetail() {
    const probe = state.probes.find((item) => item.id === state.selectedProbeId);
    if (!probe) {
      currentChatProbeId = null;
      teardownFleetChat({ clear: true });

      refs.detail.innerHTML = `
        <div class="detail-empty" id="detail-empty">
          <div class="detail-empty-title">Select a probe</div>
          <div class="detail-empty-stats">
            <span><span class="dot dot-online"></span> <strong id="cnt-online">${refs.cntOnline.textContent}</strong> online</span>
            <span><span class="dot dot-offline"></span> <strong id="cnt-offline">${refs.cntOffline.textContent}</strong> offline</span>
            <span><strong id="cnt-total">${refs.cntTotal.textContent}</strong> total</span>
          </div>
        </div>
      `;
      refs.cntOnline = document.getElementById('cnt-online');
      refs.cntOffline = document.getElementById('cnt-offline');
      refs.cntTotal = document.getElementById('cnt-total');
      return;
    }

    const serviceCount = getServices(probe).length;
    const packageCount = getPackages(probe).length;
    const tags = Array.isArray(probe.tags) ? probe.tags : [];
    const healthScore = typeof probe?.health?.score === 'number' ? probe.health.score : null;

    refs.detail.innerHTML = `
      <div class="detail-probe">
        <div class="detail-header">
          <div>
            <h2 class="detail-hostname">${esc(probe.hostname || probe.id)}</h2>
            <span class="detail-id">${esc(probe.id)}</span>
          </div>
          <div class="detail-actions">
            <a href="/probe/${encodeURIComponent(probe.id)}/chat" class="btn btn-primary">Chat</a>
            <a href="/probe/${encodeURIComponent(probe.id)}" class="btn">Full Page</a>
          </div>
        </div>

        <div class="detail-meta">
          <span class="tag tag-${statusClass(probe.status)}">${statusLabel(probe.status)}</span>
          <span class="tag">HEALTH ${healthScore === null ? '—' : esc(healthScore + '/100')}</span>
          <span>Policy: ${esc(probe.policy_level || 'observe')}</span>
          <span>Last seen: ${esc(ago(probe.last_seen))}</span>
          <span>Uptime: ${esc(elapsed(probe.registered))}</span>
          <span>OS: ${esc((probe.os || '-') + '/' + (probe.arch || '-'))}</span>
        </div>

        <div class="detail-tags">
          ${tags.length ? tags.map((tag) => `<span class="tag">${esc(tag)}</span>`).join('') : '<span class="muted">No tags</span>'}
        </div>

        <div class="detail-tabs">
          <button type="button" class="tab${state.activeTab === 'system' ? ' active' : ''}" data-tab="system">System</button>
          <button type="button" class="tab${state.activeTab === 'network' ? ' active' : ''}" data-tab="network">Network</button>
          <button type="button" class="tab${state.activeTab === 'services' ? ' active' : ''}" data-tab="services">Services <span class="tree-count-badge">${serviceCount}</span></button>
          <button type="button" class="tab${state.activeTab === 'packages' ? ' active' : ''}" data-tab="packages">Packages <span class="tree-count-badge">${packageCount}</span></button>
          <button type="button" class="tab${state.activeTab === 'chat' ? ' active' : ''}" data-tab="chat">Chat</button>
        </div>

        <div class="detail-tab-content${state.activeTab === 'chat' ? ' chat-active' : ''}">${renderTabContent(probe)}</div>
      </div>
    `;

    refs.detail.querySelectorAll('.tab').forEach((tab) => {
      tab.addEventListener('click', () => {
        state.activeTab = tab.dataset.tab || 'system';
        renderDetail();
      });
    });

    if (state.activeTab === 'chat' && currentChatProbeId === probe.id) {
      initFleetChat(probe.id);
    }
  }

  function renderFeed() {
    refs.feed.innerHTML = '';

    if (!state.feed.length) {
      refs.feed.innerHTML = '<div class="feed-empty muted">Waiting for fleet events…</div>';
      refs.feedCount.textContent = '0';
      return;
    }

    state.feed.forEach((entry) => {
      const item = document.createElement('button');
      item.type = 'button';
      item.className = 'feed-item' + (entry.probe_id ? ' clickable' : '');
      if (entry.probe_id) item.dataset.probeId = entry.probe_id;
      item.innerHTML = `
        <span class="feed-time">${esc(ago(entry.timestamp))}</span>
        <span class="feed-type tag">${esc(eventTypeLabel(entry.type))}</span>
        <span class="feed-summary">${esc(entry.summary || entry.type || 'event')}</span>
      `;
      refs.feed.appendChild(item);
    });

    refs.feedCount.textContent = String(state.feed.length);
  }

  function addFeedItem(entry) {
    const payload = {
      type: entry?.type || 'event',
      probe_id: entry?.probe_id || '',
      summary: entry?.summary || entry?.type || 'event',
      timestamp: entry?.timestamp || new Date().toISOString(),
    };

    state.feed.unshift(payload);
    if (state.feed.length > MAX_FEED) {
      state.feed.length = MAX_FEED;
    }
    renderFeed();
  }

  function selectProbe(probeId, options = {}) {
    const probe = state.probes.find((item) => item.id === probeId);
    if (!probe) return;

    if (options.reveal) {
      if (state.activeTag && !(Array.isArray(probe.tags) && probe.tags.includes(state.activeTag))) {
        state.activeTag = null;
      }
      const name = String(probe.hostname || '').toLowerCase();
      if (state.filterText && !name.includes(state.filterText)) {
        state.filterText = '';
        refs.treeFilter.value = '';
      }
    }

    if (currentChatProbeId !== probeId) {
      teardownFleetChat({ clear: true });
      currentChatProbeId = probeId;
    }

    state.selectedProbeId = probeId;
    renderTree();
    renderDetail();
    closeFleetOverlays();
  }

  async function refreshProbes() {
    try {
      const response = await fetch('/api/v1/probes', { cache: 'no-store' });
      if (!response.ok) return;
      const payload = await response.json();
      state.probes = Array.isArray(payload) ? payload : [];

      if (state.selectedProbeId && !state.probes.some((probe) => probe.id === state.selectedProbeId)) {
        state.selectedProbeId = null;
      }

      renderTree();
      renderDetail();

      if (window.LegatorUI && typeof window.LegatorUI.updateBadges === 'function') {
        window.LegatorUI.updateBadges();
      }
    } catch {
      // best effort
    }
  }

  function closeFleetOverlays() {
    document.body.classList.remove('fleet-tree-open', 'fleet-feed-open');
  }

  function initLayoutToggles() {
    refs.toggleTree?.addEventListener('click', () => {
      document.body.classList.toggle('fleet-tree-open');
      document.body.classList.remove('fleet-feed-open');
    });

    refs.toggleFeed?.addEventListener('click', () => {
      document.body.classList.toggle('fleet-feed-open');
      document.body.classList.remove('fleet-tree-open');
    });

    refs.overlayBackdrop?.addEventListener('click', closeFleetOverlays);

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        closeFleetOverlays();
      }
    });
  }

  function shouldRefresh(eventType) {
    return eventType.startsWith('probe.') || eventType === 'command.completed' || eventType === 'command.failed';
  }

  function initSSE() {
    const handlers = {
      onopen: () => {
        refs.sseDot.className = 'dot dot-online';
        refs.sseStatus.textContent = 'live';
      },
      onerror: () => {
        refs.sseDot.className = 'dot dot-offline';
        refs.sseStatus.textContent = 'reconnecting…';
      },
    };

    const events = [
      'probe.connected',
      'probe.disconnected',
      'probe.offline',
      'probe.registered',
      'probe.updated',
      'command.dispatched',
      'command.completed',
      'command.failed',
      'approval.needed',
      'approval.decided',
      'policy.changed',
      'chat.message',
    ];

    events.forEach((eventType) => {
      handlers[eventType] = (payload) => {
        const entry = Object.assign({}, payload || {}, { type: payload?.type || eventType });
        addFeedItem(entry);
        if (shouldRefresh(eventType)) {
          refreshProbes();
        }
      };
    });

    if (window.LegatorUI && typeof window.LegatorUI.connectSSE === 'function') {
      window.LegatorUI.connectSSE(handlers);
    }
  }

  refs.treeFilter.addEventListener('input', (event) => {
    state.filterText = String(event.target.value || '').trim().toLowerCase();
    renderTree();
  });

  refs.feed.addEventListener('click', (event) => {
    const row = event.target.closest('.feed-item[data-probe-id]');
    if (!row) return;
    selectProbe(row.dataset.probeId, { reveal: true });
  });

  initLayoutToggles();
  renderTree();
  renderDetail();
  renderFeed();
  refreshProbes();
  initSSE();

  if (window.LegatorUI && typeof window.LegatorUI.initResizable === 'function') {
    window.LegatorUI.initResizable();
  }

  window.setInterval(refreshProbes, 30000);
})();
</script>
{{end}}
