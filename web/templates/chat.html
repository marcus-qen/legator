<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Legator · Probe {{.ProbeID}} · Chat</title>
    <link rel="stylesheet" href="/static/style.css" />
    <style>
      .chat-shell {
        max-width: 1100px;
        margin: 0 auto;
        min-height: 100vh;
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
      }

      .chat-header {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: flex-start;
        gap: 0.8rem;
      }

      .chat-title {
        margin: 0 0 0.35rem 0;
        font-size: 1.6rem;
      }

      .chat-title-meta {
        margin: 0;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 0.65rem;
        align-items: center;
      }

      .chat-layout {
        flex: 1;
        display: flex;
        flex-direction: column;
        margin-top: 0.75rem;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        padding: 0.8rem;
      }

      .status-pill {
        margin-top: 0.4rem;
      }

      .connection-status {
        display: inline-flex;
        align-items: center;
        gap: 0.45rem;
        color: var(--muted);
        font-size: 0.88rem;
      }

      .connection-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        border: 1px solid transparent;
      }

      .connected {
        background: var(--green);
        box-shadow: 0 0 6px rgba(46, 160, 67, 0.5);
      }

      .disconnected {
        background: var(--red);
        box-shadow: 0 0 6px rgba(248, 81, 73, 0.35);
      }

      .chat-messages {
        flex: 1;
        min-height: 55vh;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 0.4rem;
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }

      .chat-empty {
        text-align: center;
        margin: auto;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .message-row {
        display: flex;
        width: 100%;
      }

      .message-row.user {
        justify-content: flex-end;
      }

      .message-row.assistant {
        justify-content: flex-start;
      }

      .message-row.system {
        justify-content: center;
      }

      .chat-message {
        max-width: min(82%, 76ch);
        border: 1px solid transparent;
        border-radius: 0.7rem;
        padding: 0.75rem 0.85rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        line-height: 1.38;
      }

      .chat-message.user {
        background: var(--blue);
        color: var(--bg);
        border-color: rgba(88, 166, 255, 0.35);
      }

      .chat-message.assistant {
        background: var(--panel-2);
        color: var(--text);
        border-color: rgba(255, 255, 255, 0.06);
      }

      .chat-message.system {
        background: transparent;
        color: var(--muted);
        border-color: transparent;
        text-align: center;
        max-width: 100%;
        font-style: italic;
      }

      .chat-meta {
        margin-top: 0.4rem;
        font-size: 0.75rem;
        opacity: 0.8;
      }

      .chat-command-id {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        color: var(--muted);
      }

      .chat-code {
        margin: 0.55rem 0 0;
        padding: 0.6rem 0.7rem;
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        background: var(--panel-3);
        overflow-x: auto;
      }

      .chat-composer {
        margin-top: 0.75rem;
        display: flex;
        gap: 0.65rem;
        align-items: flex-end;
      }

      #chat-input {
        flex: 1;
        min-height: 44px;
        border-radius: 0.6rem;
        border: 1px solid var(--border);
        background: var(--panel-2);
        color: var(--text);
        padding: 0.7rem 0.8rem;
        font-size: 1rem;
        resize: vertical;
      }

      #chat-input:focus {
        outline: 2px solid rgba(88, 166, 255, 0.45);
        outline-offset: 0;
      }

      #send-btn {
        height: 44px;
        border: 1px solid var(--border);
        border-radius: 0.6rem;
        background: var(--blue);
        color: var(--bg);
        padding: 0 1rem;
        font-weight: 700;
        cursor: pointer;
      }

      #send-btn[disabled],
      #chat-input[disabled] {
        opacity: 0.7;
        cursor: not-allowed;
      }

      .typing {
        color: var(--muted);
        font-size: 0.84rem;
        margin-top: 0.6rem;
        min-height: 1rem;
      }

      .typing.show {
        opacity: 1;
      }

      .typing:not(.show) {
        opacity: 0;
        height: 0;
        margin-top: 0;
        overflow: hidden;
      }

      .typing-dot {
        display: inline-block;
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: var(--muted);
        margin-left: 0.35rem;
        animation: blink 1.1s infinite;
      }

      @keyframes blink {
        0%,
        80%,
        100% {
          transform: scale(1);
          opacity: 0.2;
        }
        40% {
          transform: scale(1.45);
          opacity: 1;
        }
      }

      @media (max-width: 700px) {
        .chat-shell {
          padding: 0.7rem;
        }

        .chat-title {
          font-size: 1.35rem;
        }

        .chat-message {
          max-width: 88%;
          font-size: 0.95rem;
        }

        .chat-layout {
          padding: 0.55rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="chat-shell">
      <section class="chat-header">
        <div>
          <a href="/probe/{{.ProbeID}}" class="back-link">← Back to Probe</a>
          <h1 class="chat-title">{{if .Hostname}}{{.Hostname}}{{else}}{{.ProbeID}}{{end}}</h1>
          <p class="chat-title-meta">
            <span>Probe ID: {{.ProbeID}}</span>
            <span class="separator">•</span>
            <span class="status-pill status-{{if or (eq .Status "online") (eq .Status "pending") (eq .Status "degraded") (eq .Status "offline")}}{{.Status}}{{else}}pending{{end}}">{{if .Status}}{{.Status}}{{else}}unknown{{end}}</span>
            <span class="separator">•</span>
            <span id="connection-status" class="connection-status">
              <span id="connection-dot" class="connection-dot disconnected"></span>
              <span id="connection-text">Disconnected</span>
            </span>
          </p>
        </div>
      </section>

      <section class="chat-layout">
        <section id="message-list" class="chat-messages" aria-live="polite"></section>
        <div id="empty-state" class="chat-empty">No messages yet. Start a conversation.</div>
        <div id="typing" class="typing" aria-live="polite">Assistant is typing<span class="typing-dot"></span></div>

        <form id="chat-form" class="chat-composer" autocomplete="off">
          <input
            id="chat-input"
            name="message"
            placeholder="Ask this probe for help..."
            maxlength="4000"
            autocomplete="off"
            required
          />
          <button id="send-btn" type="submit">Send</button>
        </form>
      </section>
    </main>

    <script>
      (() => {
        const messageList = document.getElementById("message-list");
        const emptyState = document.getElementById("empty-state");
        const chatForm = document.getElementById("chat-form");
        const input = document.getElementById("chat-input");
        const sendButton = document.getElementById("send-btn");
        const typing = document.getElementById("typing");
        const connectionDot = document.getElementById("connection-dot");
        const connectionText = document.getElementById("connection-text");

        const pathParts = window.location.pathname.split("/").filter(Boolean);
        const probeID = pathParts[1] || "";

        const knownMessageIds = new Set();
        let awaitingReply = false;
        let ws = null;
        let wsConnected = false;
        let reconnectTimeout = null;
        let pollTimer = null;

        const limit = 200;

        function toISODate(value) {
          if (!value) return "";
          const parsed = new Date(value);
          if (Number.isNaN(parsed.getTime())) return "";
          return parsed.toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
          });
        }

        function updateConnection(connected) {
          wsConnected = connected;
          if (connected) {
            connectionDot.classList.remove("disconnected");
            connectionDot.classList.add("connected");
            connectionText.textContent = "Connected";
          } else {
            connectionDot.classList.remove("connected");
            connectionDot.classList.add("disconnected");
            connectionText.textContent = "Disconnected";
          }
        }

        function setTyping(isTyping) {
          typing.classList.toggle("show", isTyping);
          input.disabled = isTyping;
          sendButton.disabled = isTyping;
        }

        function scrollToBottom() {
          messageList.scrollTop = messageList.scrollHeight;
        }

        function renderPlainText(container, text) {
          const line = document.createElement("div");
          line.className = "chat-body";
          line.textContent = text;
          container.appendChild(line);
        }

        function renderContent(container, content) {
          if (!content) {
            const empty = document.createElement("div");
            empty.className = "chat-body";
            empty.textContent = "";
            container.appendChild(empty);
            return;
          }

          const text = String(content);
          const codePattern = /```(?:[a-zA-Z0-9_+-]*)?\n?([\s\S]*?)```/g;

          let last = 0;
          let hasBlock = false;
          let match;

          while ((match = codePattern.exec(text)) !== null) {
            hasBlock = true;
            const before = text.slice(last, match.index);
            if (before.trim()) {
              renderPlainText(container, before);
            }

            const snippet = document.createElement("pre");
            snippet.className = "chat-code";
            snippet.textContent = (match[1] || "").replace(/^\n/, "").trimRight();
            container.appendChild(snippet);

            last = match.index + match[0].length;
          }

          if (!hasBlock) {
            renderPlainText(container, text);
            return;
          }

          const remaining = text.slice(last);
          if (remaining.trim()) {
            renderPlainText(container, remaining);
          }
        }

        function renderMessage(message) {
          if (!message || !message.id || knownMessageIds.has(message.id)) {
            return;
          }
          knownMessageIds.add(message.id);

          emptyState.style.display = "none";

          const role = message.role || "system";
          const row = document.createElement("article");
          row.className = `message-row ${role}`;

          const bubble = document.createElement("div");
          bubble.className = `chat-message ${role}`;

          const body = document.createElement("div");
          renderContent(body, message.content);
          bubble.appendChild(body);

          if (message.command_id) {
            const cmd = document.createElement("div");
            cmd.className = "chat-meta chat-command-id";
            cmd.textContent = `command: ${message.command_id}`;
            bubble.appendChild(cmd);
          }

          if (message.timestamp) {
            const meta = document.createElement("div");
            meta.className = "chat-meta";
            meta.textContent = toISODate(message.timestamp);
            bubble.appendChild(meta);
          }

          row.appendChild(bubble);
          messageList.appendChild(row);
          scrollToBottom();

          if (awaitingReply && role !== "user") {
            awaitingReply = false;
            setTyping(false);
          }
        }

        async function loadHistory() {
          if (!probeID || wsConnected) {
            return;
          }

          try {
            const resp = await fetch(`/api/v1/probes/${probeID}/chat?limit=${limit}`, {
              method: "GET",
              headers: {
                "Accept": "application/json",
              },
            });

            if (!resp.ok) {
              return;
            }

            const messages = await resp.json();
            if (!Array.isArray(messages)) {
              return;
            }

            messages.forEach((msg) => {
              renderMessage(msg);
            });
          } catch {
            // no-op: polling is best-effort
          }
        }

        function startPolling() {
          if (pollTimer) {
            return;
          }
          pollTimer = window.setInterval(() => {
            loadHistory();
          }, 3000);
          loadHistory();
        }

        function stopPolling() {
          if (!pollTimer) {
            return;
          }
          clearInterval(pollTimer);
          pollTimer = null;
        }

        function connectChatSocket() {
          if (!probeID) {
            startPolling();
            return;
          }

          if (ws) {
            ws.close();
          }

          const wsScheme = location.protocol === "https:" ? "wss:" : "ws:";
          const wsURL = `${wsScheme}://${location.host}/ws/chat?probe_id=${encodeURIComponent(probeID)}`;
          ws = new WebSocket(wsURL);

          ws.onopen = () => {
            updateConnection(true);
            stopPolling();
            if (reconnectTimeout) {
              clearTimeout(reconnectTimeout);
              reconnectTimeout = null;
            }
          };

          ws.onmessage = (event) => {
            if (!event.data) {
              return;
            }

            let message;
            try {
              message = JSON.parse(event.data);
            } catch {
              return;
            }
            renderMessage(message);
          };

          ws.onclose = () => {
            updateConnection(false);
            startPolling();
            if (!reconnectTimeout) {
              reconnectTimeout = window.setTimeout(connectChatSocket, 3000);
            }
          };

          ws.onerror = () => {
            if (ws) {
              ws.close();
            }
          };
        }

        async function sendViaREST(content) {
          const response = await fetch(`/api/v1/probes/${probeID}/chat`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Accept": "application/json",
            },
            body: JSON.stringify({ content }),
          });

          if (!response.ok) {
            throw new Error("failed to send message");
          }

          const assistantMessage = await response.json();
          renderMessage(assistantMessage);

          return assistantMessage;
        }

        chatForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (awaitingReply || !probeID) {
            return;
          }

          const content = input.value.trim();
          if (!content) {
            return;
          }

          input.value = "";
          awaitingReply = true;
          setTyping(true);

          const localMessage = {
            id: `local-${Date.now()}`,
            role: "user",
            content,
            timestamp: new Date().toISOString(),
          };

          renderMessage(localMessage);

          if (wsConnected && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ content }));
            return;
          }

          try {
            await sendViaREST(content);
          } catch (error) {
            awaitingReply = false;
            setTyping(false);
            renderMessage({
              id: `err-${Date.now()}`,
              role: "system",
              content: "Unable to send chat message. Check connection and try again.",
              timestamp: new Date().toISOString(),
            });
          }
        });

        setTyping(false);
        connectChatSocket();
        startPolling();
      })();
    </script>
  </body>
</html>
