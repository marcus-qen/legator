{{define "title"}}Probe {{.Probe.ID}} — Legator{{end}}

{{define "header"}}
<div>
  <h1 id="probe-hostname-title" class="page-title">{{if .Probe.Inventory}}{{if .Probe.Inventory.Hostname}}{{.Probe.Inventory.Hostname}}{{else}}{{if .Probe.Hostname}}{{.Probe.Hostname}}{{else}}(unknown){{end}}{{end}}{{else}}{{if .Probe.Hostname}}{{.Probe.Hostname}}{{else}}(unknown){{end}}{{end}}</h1>
  <span class="page-meta">Probe <span id="probe-id" class="id-text">{{.Probe.ID}}</span> · v{{.Version}}</span>
</div>
<div class="right">
  <a href="/probe/{{.Probe.ID}}/chat" class="btn btn-primary">Open Chat</a>
</div>
{{end}}

{{define "content"}}
{{$statusClass := statusClass .Probe.Status}}
{{$healthScore := 18}}
{{$healthClass := "health-bad"}}
{{if .Probe.Health}}
  {{$healthScore = .Probe.Health.Score}}
  {{if ge .Probe.Health.Score 80}}
    {{$healthClass = "health-ok"}}
  {{else if ge .Probe.Health.Score 50}}
    {{$healthClass = "health-warn"}}
  {{else}}
    {{$healthClass = "health-bad"}}
  {{end}}
{{else if eq $statusClass "online"}}
  {{$healthScore = 100}}
  {{$healthClass = "health-ok"}}
{{else if eq $statusClass "degraded"}}
  {{$healthScore = 63}}
  {{$healthClass = "health-warn"}}
{{else if eq $statusClass "pending"}}
  {{$healthScore = 49}}
  {{$healthClass = "health-warn"}}
{{end}}

<section class="panel">
  <div class="stat-row">
    <span id="probe-status-badge" class="tag tag-{{$statusClass}}">{{humanizeStatus .Probe.Status}}</span>
    <span id="probe-health-badge" class="tag {{$healthClass}}">Health <span id="probe-health-score">{{$healthScore}}</span>/100</span>
    <span>Policy: <strong id="probe-policy">{{.Probe.PolicyLevel}}</strong></span>
    <span>Last seen: <strong id="probe-last-seen">{{formatLastSeen .Probe.LastSeen}}</strong></span>
    <span>Uptime: <strong id="probe-uptime">{{.Uptime}}</strong></span>
    <span id="probe-conn-badge" class="tag">reconnecting</span>
  </div>
  <div class="health-meter wide">
    <span class="health-track"><span class="health-fill {{$healthClass}}" id="probe-health-fill" style="width:{{$healthScore}}%"></span></span>
    <span class="health-score"><span id="probe-health-percent">{{$healthScore}}</span>%</span>
  </div>
  <div class="muted" id="probe-refresh-note" role="status" aria-live="polite"></div>
</section>

<section class="grid-two">
  <article class="panel">
    <div class="panel-header"><h2 class="panel-title">System</h2></div>
    <dl class="kv-grid">
      <dt>Hostname</dt>
      <dd id="probe-hostname-field">{{if .Probe.Inventory}}{{if .Probe.Inventory.Hostname}}{{.Probe.Inventory.Hostname}}{{else}}{{if .Probe.Hostname}}{{.Probe.Hostname}}{{else}}-{{end}}{{end}}{{else}}{{if .Probe.Hostname}}{{.Probe.Hostname}}{{else}}-{{end}}{{end}}</dd>
      <dt>OS</dt>
      <dd id="probe-os-field">{{if .Probe.Inventory}}{{if .Probe.Inventory.OS}}{{.Probe.Inventory.OS}}{{else}}{{if .Probe.OS}}{{.Probe.OS}}{{else}}-{{end}}{{end}}{{else}}{{if .Probe.OS}}{{.Probe.OS}}{{else}}-{{end}}{{end}}</dd>
      <dt>Arch</dt>
      <dd id="probe-arch-field">{{if .Probe.Inventory}}{{if .Probe.Inventory.Arch}}{{.Probe.Inventory.Arch}}{{else}}{{if .Probe.Arch}}{{.Probe.Arch}}{{else}}-{{end}}{{end}}{{else}}{{if .Probe.Arch}}{{.Probe.Arch}}{{else}}-{{end}}{{end}}</dd>
      <dt>Kernel</dt>
      <dd id="probe-kernel-field">{{if .Probe.Inventory}}{{if .Probe.Inventory.Kernel}}{{.Probe.Inventory.Kernel}}{{else}}-{{end}}{{else}}-{{end}}</dd>
      <dt>CPUs</dt>
      <dd id="probe-cpus-field">{{if .Probe.Inventory}}{{.Probe.Inventory.CPUs}}{{else}}-{{end}}</dd>
      <dt>Memory</dt>
      <dd id="probe-memory-field">{{if .Probe.Inventory}}{{humanBytes .Probe.Inventory.MemTotal}}{{else}}-{{end}}</dd>
      <dt>Disk</dt>
      <dd id="probe-disk-field">{{if .Probe.Inventory}}{{humanBytes .Probe.Inventory.DiskTotal}}{{else}}-{{end}}</dd>
    </dl>
  </article>

  <article class="panel">
    <div class="panel-header"><h2 class="panel-title">Tags</h2></div>
    <div>
      {{if .Probe.Tags}}{{range .Probe.Tags}}<span class="tag">{{.}}</span>{{end}}{{else}}<span class="muted">No tags</span>{{end}}
    </div>
    <div class="actions-row">
      <a href="/probe/{{.Probe.ID}}/chat" class="btn btn-primary">Chat</a>
      <a href="/" class="btn">Back</a>
    </div>
  </article>

  <article class="panel">
    <div class="panel-header"><h2 class="panel-title">Network</h2></div>
    {{with .Probe.Inventory}}{{if .Interfaces}}
    <ul class="feed">
      {{range .Interfaces}}<li class="feed-item"><strong>{{.Name}}</strong> {{if .MAC}}· {{.MAC}}{{end}} <span class="muted">{{.State}} {{range .Addrs}}{{.}} {{end}}</span></li>{{end}}
    </ul>
    {{else}}<div class="empty-state">No interfaces reported</div>{{end}}{{else}}<div class="empty-state">No interfaces reported</div>{{end}}
  </article>

  <article class="panel">
    <div class="panel-header"><h2 class="panel-title">Services</h2></div>
    {{with .Probe.Inventory}}{{if .Services}}
    <ul class="feed">
      {{range .Services}}<li class="feed-item">{{.Name}} <span class="muted">{{.State}} · enabled={{.Enabled}}</span></li>{{end}}
    </ul>
    {{else}}<div class="empty-state">No services reported</div>{{end}}{{else}}<div class="empty-state">No services reported</div>{{end}}
  </article>
</section>

<section class="panel">
  <div class="panel-header"><h2 class="panel-title">Packages</h2></div>
  {{with .Probe.Inventory}}{{if .Packages}}
  <ul class="feed">
    {{range .Packages}}<li class="feed-item">{{.Name}} <span class="muted">{{.Version}} ({{.Manager}})</span></li>{{end}}
  </ul>
  {{else}}<div class="empty-state">No packages reported</div>{{end}}{{else}}<div class="empty-state">No packages reported</div>{{end}}
</section>
{{end}}

{{define "scripts"}}
<script>
(function () {
  const PROBE_ID = '{{.Probe.ID}}';
  const MAX_FETCH_FAILURES = 5;
  const MAX_SSE_FAILURES = 8;
  const BASE_RECONNECT_MS = 1000;
  const MAX_RECONNECT_MS = 30000;
  const REFRESH_INTERVAL_MS = 30000;

  const state = {
    source: null,
    reconnectTimer: null,
    reconnectAttempt: 0,
    periodicRefresh: null,
    fetchInFlight: false,
    fetchFailures: 0,
    sseFailures: 0,
    hardReloadScheduled: false,
  };

  const refs = {
    statusBadge: document.getElementById('probe-status-badge'),
    healthBadge: document.getElementById('probe-health-badge'),
    healthScore: document.getElementById('probe-health-score'),
    lastSeen: document.getElementById('probe-last-seen'),
    uptime: document.getElementById('probe-uptime'),
    policy: document.getElementById('probe-policy'),
    hostTitle: document.getElementById('probe-hostname-title'),
    hostField: document.getElementById('probe-hostname-field'),
    osField: document.getElementById('probe-os-field'),
    archField: document.getElementById('probe-arch-field'),
    kernelField: document.getElementById('probe-kernel-field'),
    cpusField: document.getElementById('probe-cpus-field'),
    memoryField: document.getElementById('probe-memory-field'),
    diskField: document.getElementById('probe-disk-field'),
    connBadge: document.getElementById('probe-conn-badge'),
    refreshNote: document.getElementById('probe-refresh-note'),
  };

  function setText(node, value) {
    if (!node) return;
    node.textContent = value;
  }

  function normalizeStatus(value) {
    const status = (value || 'pending').toString().toLowerCase();
    if (status === 'online' || status === 'offline' || status === 'degraded') {
      return status;
    }
    return 'pending';
  }

  function statusClass(status) {
    return 'tag tag-' + normalizeStatus(status);
  }

  function humanizeStatus(value) {
    const status = normalizeStatus(value);
    return status.charAt(0).toUpperCase() + status.slice(1);
  }

  function fallbackHealth(status) {
    const normalized = normalizeStatus(status);
    if (normalized === 'online') return {score: 100, className: 'health-ok'};
    if (normalized === 'degraded') return {score: 63, className: 'health-warn'};
    if (normalized === 'pending') return {score: 49, className: 'health-warn'};
    return {score: 18, className: 'health-bad'};
  }

  function healthPayload(probe, status) {
    if (probe && probe.health && typeof probe.health.score === 'number' && Number.isFinite(probe.health.score)) {
      const score = Math.max(0, Math.min(100, Math.round(probe.health.score)));
      if (score >= 80) return {score: score, className: 'health-ok'};
      if (score >= 50) return {score: score, className: 'health-warn'};
      return {score: score, className: 'health-bad'};
    }
    return fallbackHealth(status);
  }

  function isoOrFallback(raw) {
    if (!raw) return '-';
    const ts = new Date(raw);
    if (Number.isNaN(ts.getTime())) return String(raw);
    return ts.toISOString();
  }

  function formatUptime(registered) {
    if (!registered) return 'n/a';
    const ts = new Date(registered);
    if (Number.isNaN(ts.getTime())) return 'n/a';

    let seconds = Math.max(0, Math.floor((Date.now() - ts.getTime()) / 1000));
    if (seconds < 60) return `${seconds}s`;

    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    const days = Math.floor(hours / 24);
    const hrs = hours % 24;

    const parts = [];
    if (days > 0) parts.push(`${days}d`);
    if (hrs > 0) parts.push(`${hrs}h`);
    if (mins > 0) parts.push(`${mins}m`);
    if (!parts.length) parts.push(`${secs}s`);
    return parts.join(' ');
  }

  function humanBytes(value) {
    const bytes = Number(value);
    if (!Number.isFinite(bytes) || bytes <= 0) return '-';
    const units = ['B', 'KiB', 'MiB', 'GiB', 'TiB'];
    let val = bytes;
    let unit = 0;
    while (unit < units.length - 1 && val >= 1024) {
      val /= 1024;
      unit += 1;
    }
    if (unit === 0) return `${Math.round(val)} ${units[unit]}`;
    return `${val.toFixed(1)} ${units[unit]}`;
  }

  function setConnectionState(isLive) {
    if (!refs.connBadge) return;
    refs.connBadge.className = 'tag ' + (isLive ? 'tag-online' : 'tag-offline');
    refs.connBadge.textContent = isLive ? 'live' : 'reconnecting';
  }

  function setRefreshNote(message) {
    if (!refs.refreshNote) return;
    refs.refreshNote.textContent = message || '';
  }

  function applyStatus(status) {
    if (!refs.statusBadge) return;
    refs.statusBadge.className = statusClass(status);
    refs.statusBadge.textContent = humanizeStatus(status);
  }

  function applyHealth(health) {
    if (!refs.healthBadge || !health) return;
    refs.healthBadge.className = `tag ${health.className}`;
    setText(refs.healthScore, String(health.score));
    const fill = document.getElementById('probe-health-fill');
    const pct = document.getElementById('probe-health-percent');
    if (fill) {
      fill.className = `health-fill ${health.className}`;
      fill.style.width = `${health.score}%`;
    }
    if (pct) pct.textContent = String(health.score);
  }

  function applyLastSeen(raw) {
    setText(refs.lastSeen, isoOrFallback(raw));
  }

  function extractEventStatus(eventType, evt) {
    const detail = evt && evt.detail && typeof evt.detail === 'object' ? evt.detail : {};
    if (typeof detail.status === 'string' && detail.status) {
      return detail.status;
    }
    if (eventType === 'probe.connected') return 'online';
    if (eventType === 'probe.disconnected') return 'degraded';
    if (eventType === 'probe.offline') return 'offline';
    return 'pending';
  }

  function extractEventLastSeen(evt) {
    const detail = evt && evt.detail && typeof evt.detail === 'object' ? evt.detail : {};
    if (typeof detail.last_seen === 'string' && detail.last_seen) {
      return detail.last_seen;
    }
    if (evt && typeof evt.timestamp === 'string' && evt.timestamp) {
      return evt.timestamp;
    }
    return new Date().toISOString();
  }

  function applyProbeSnapshot(probe) {
    if (!probe || typeof probe !== 'object') return;

    const status = normalizeStatus(probe.status);
    applyStatus(status);
    applyHealth(healthPayload(probe, status));
    applyLastSeen(probe.last_seen);
    setText(refs.uptime, formatUptime(probe.registered));
    if (probe.policy_level) {
      setText(refs.policy, probe.policy_level);
    }

    const inv = probe.inventory && typeof probe.inventory === 'object' ? probe.inventory : null;
    const hostname = inv && inv.hostname ? inv.hostname : (probe.hostname || '-');
    const osName = inv && inv.os ? inv.os : (probe.os || '-');
    const arch = inv && inv.arch ? inv.arch : (probe.arch || '-');
    const kernel = inv && inv.kernel ? inv.kernel : '-';
    const cpus = inv && Number.isFinite(Number(inv.cpus)) ? String(Number(inv.cpus)) : '-';
    const memory = inv ? humanBytes(inv.mem_total_bytes) : '-';
    const disk = inv ? humanBytes(inv.disk_total_bytes) : '-';

    setText(refs.hostTitle, hostname || '(unknown)');
    setText(refs.hostField, hostname || '-');
    setText(refs.osField, osName || '-');
    setText(refs.archField, arch || '-');
    setText(refs.kernelField, kernel);
    setText(refs.cpusField, cpus);
    setText(refs.memoryField, memory);
    setText(refs.diskField, disk);
  }

  function parseEventData(raw) {
    if (!raw) return null;
    try {
      return JSON.parse(raw);
    } catch (_) {
      return null;
    }
  }

  function maybeHardReload(reason) {
    if (state.hardReloadScheduled) return;
    if (state.fetchFailures < MAX_FETCH_FAILURES || state.sseFailures < MAX_SSE_FAILURES) return;
    state.hardReloadScheduled = true;
    setRefreshNote(`Live updates stalled (${reason}); refreshing page…`);
    window.setTimeout(function () {
      window.location.reload();
    }, 400);
  }

  async function refreshProbe(reason) {
    if (state.fetchInFlight) return;
    state.fetchInFlight = true;
    try {
      const response = await fetch(`/api/v1/probes/${encodeURIComponent(PROBE_ID)}`, {
        cache: 'no-store',
        headers: { 'Accept': 'application/json' },
      });
      if (!response.ok) throw new Error(`status ${response.status}`);
      const payload = await response.json();
      applyProbeSnapshot(payload);
      state.fetchFailures = 0;
      if (state.sseFailures < MAX_SSE_FAILURES) setRefreshNote('');
    } catch (error) {
      state.fetchFailures += 1;
      setRefreshNote(`Probe refresh failed (${reason}): ${error.message}`);
      maybeHardReload('api');
    } finally {
      state.fetchInFlight = false;
    }
  }

  function handleProbeEvent(eventType, evt) {
    if (!evt || evt.probe_id !== PROBE_ID) return;
    const status = extractEventStatus(eventType, evt);
    applyStatus(status);
    applyHealth(fallbackHealth(status));
    applyLastSeen(extractEventLastSeen(evt));
  }

  function closeSource() {
    if (state.source) {
      state.source.close();
      state.source = null;
    }
  }

  function scheduleReconnect() {
    if (state.reconnectTimer) return;
    const exp = Math.min(state.reconnectAttempt, 6);
    const delay = Math.min(MAX_RECONNECT_MS, BASE_RECONNECT_MS * (2 ** exp));
    state.reconnectAttempt += 1;
    state.reconnectTimer = window.setTimeout(function () {
      state.reconnectTimer = null;
      connectSSE();
    }, delay);
  }

  function connectSSE() {
    if (state.source) return;

    setConnectionState(false);
    const source = new EventSource('/api/v1/events');
    state.source = source;

    source.onopen = function () {
      if (state.source !== source) return;
      state.reconnectAttempt = 0;
      state.sseFailures = 0;
      setConnectionState(true);
    };

    source.onerror = function () {
      if (state.source !== source) return;
      state.sseFailures += 1;
      closeSource();
      setConnectionState(false);
      scheduleReconnect();
      maybeHardReload('sse');
    };

    ['probe.connected', 'probe.disconnected', 'probe.offline'].forEach(function (eventType) {
      source.addEventListener(eventType, function (e) {
        const evt = parseEventData(e.data);
        handleProbeEvent(eventType, evt);
      });
    });

    ['command.completed', 'command.failed'].forEach(function (eventType) {
      source.addEventListener(eventType, function (e) {
        const evt = parseEventData(e.data);
        if (!evt || evt.probe_id !== PROBE_ID) return;
        void refreshProbe(eventType);
      });
    });
  }

  function teardown() {
    if (state.reconnectTimer) {
      window.clearTimeout(state.reconnectTimer);
      state.reconnectTimer = null;
    }
    if (state.periodicRefresh) {
      window.clearInterval(state.periodicRefresh);
      state.periodicRefresh = null;
    }
    closeSource();
  }

  state.periodicRefresh = window.setInterval(function () {
    void refreshProbe('periodic');
  }, REFRESH_INTERVAL_MS);

  window.addEventListener('beforeunload', teardown);

  void refreshProbe('initial');
  connectSSE();
})();
</script>
{{end}}
