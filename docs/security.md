# Security Model

Legator implements defence-in-depth: multiple independent security layers that each prevent or limit damage even when others fail.

---

## 1. Authentication

### API Keys

API keys use the `lgk_` prefix followed by 64 lowercase hexadecimal characters (32 bytes of `crypto/rand`):

```
lgk_a1b2c3d4e5f6...64hexchars
```

Keys are generated by `GenerateAPIKey()` in `internal/controlplane/api/register.go`. They are stored **hashed** — the raw value is only visible at creation time. Probes receive their key during registration (`POST /api/v1/register`).

**Sending API keys:**
```http
Authorization: Bearer lgk_a1b2c3d4e5f6...
```

**Key scopes:** Each API key carries an explicit permission list. A key can have any subset of permissions regardless of what "role" it was created with.

**Key rotation:** `POST /api/v1/probes/{id}/rotate-key` generates a new key and pushes it over the live WebSocket connection atomically.

### Session Cookies (Web UI / Login Page)

The `/login` page accepts `username` + `password` (bcrypt, cost 10). On success, a signed session cookie is set. Session lifetime: 24 hours (`sessionMaxAgeSeconds = 86400`).

Sessions are stored in the session store (in-memory or SQLite). `POST /logout` invalidates the session immediately.

### OIDC SSO

OIDC is optional. When enabled (`LEGATOR_OIDC_*`), the login page shows a provider button. The flow:

1. `GET /auth/oidc/login` — generates PKCE verifier + S256 challenge, random state + nonce. Redirects to provider authorization endpoint.
2. Provider redirects to `GET /auth/oidc/callback` with `code` + `state`.
3. Control plane validates:
   - `state` matches stored value (CSRF prevention)
   - Exchanges code for tokens using PKCE verifier
   - Verifies ID token signature against provider JWKS
   - Validates `nonce` in ID token (replay prevention)
4. No access tokens are stored — a Legator session is created from the ID token claims.

**PKCE:** S256 method enforced. No implicit flow. No `response_type=token`.

### Authentication Priority

When both are enabled, the middleware checks (in order):
1. `Authorization: Bearer lgk_*` header → API key auth
2. Session cookie → session auth
3. Neither → 401 Unauthorized

---

## 2. Authorisation

### Permission Levels

| Permission | Constant | Description |
|---|---|---|
| `PermAdmin` | `admin` | User/key management, audit purge, token listing |
| `PermFleetRead` | `fleet:read` | Read fleet, probes, reliability, alerts, jobs, federation |
| `PermFleetWrite` | `fleet:write` | Modify fleet, dispatch commands, manage policies/alerts/jobs |
| `PermCommandExec` | `command:exec` | Dispatch commands, view pending/streaming commands |
| `PermApprovalRead` | `approval:read` | View approval queue |
| `PermApprovalWrite` | `approval:write` | Decide on approvals |
| `PermAuditRead` | `audit:read` | Read audit log |
| `PermWebhookManage` | `webhook:manage` | CRUD webhooks and view delivery log |

### Endpoint Permission Map

| Method | Path | Permission |
|---|---|---|
| GET | `/api/v1/me` | Any authenticated |
| GET | `/api/v1/users` | PermAdmin |
| POST | `/api/v1/users` | PermAdmin |
| DELETE | `/api/v1/users/{id}` | PermAdmin |
| GET | `/api/v1/auth/keys` | PermAdmin |
| POST | `/api/v1/auth/keys` | PermAdmin |
| DELETE | `/api/v1/auth/keys/{id}` | PermAdmin |
| GET | `/api/v1/tokens` | PermAdmin |
| POST | `/api/v1/tokens` | PermFleetWrite |
| POST | `/api/v1/register` | Token (no user auth) |
| GET | `/api/v1/probes` | PermFleetRead |
| GET | `/api/v1/probes/{id}` | PermFleetRead |
| GET | `/api/v1/probes/{id}/health` | PermFleetRead |
| POST | `/api/v1/probes/{id}/command` | PermFleetWrite + PermCommandExec |
| POST | `/api/v1/probes/{id}/rotate-key` | PermFleetWrite |
| POST | `/api/v1/probes/{id}/update` | PermFleetWrite |
| PUT | `/api/v1/probes/{id}/tags` | PermFleetWrite |
| POST | `/api/v1/probes/{id}/apply-policy/{id}` | PermFleetWrite |
| POST | `/api/v1/probes/{id}/task` | PermFleetWrite + PermCommandExec |
| DELETE | `/api/v1/probes/{id}` | PermFleetWrite |
| GET | `/api/v1/fleet/*` | PermFleetRead |
| POST | `/api/v1/fleet/by-tag/{tag}/command` | PermFleetWrite |
| POST | `/api/v1/fleet/cleanup` | PermFleetWrite |
| GET | `/api/v1/federation/*` | PermFleetRead |
| GET | `/api/v1/reliability/*` | PermFleetRead |
| POST/PATCH/DELETE | `/api/v1/reliability/*` | PermFleetWrite |
| GET | `/api/v1/alerts*` | PermFleetRead |
| POST/PUT/DELETE | `/api/v1/alerts*` | PermFleetWrite |
| GET | `/api/v1/policies*` | PermFleetRead |
| POST/DELETE | `/api/v1/policies*` | PermFleetWrite |
| GET | `/api/v1/approvals*` | PermApprovalRead |
| POST | `/api/v1/approvals/{id}/decide` | PermApprovalWrite |
| GET | `/api/v1/audit` | PermAuditRead |
| GET | `/api/v1/audit/export*` | PermAuditRead |
| DELETE | `/api/v1/audit/purge` | PermAdmin |
| GET/POST | `/api/v1/webhooks*` | PermWebhookManage |
| GET | `/api/v1/jobs*` | PermFleetRead |
| POST/PUT/DELETE | `/api/v1/jobs*` | PermFleetWrite |
| GET | `/api/v1/cloud/*` | PermFleetRead |
| POST/PUT/DELETE | `/api/v1/cloud/*` | PermFleetWrite |
| GET | `/api/v1/model-profiles*` | PermFleetRead |
| POST/PUT/DELETE | `/api/v1/model-profiles*` | PermFleetWrite |
| GET | `/api/v1/network/devices*` | PermFleetRead |
| POST/PUT/DELETE | `/api/v1/network/devices*` | PermFleetWrite |
| GET | `/api/v1/discovery/*` | PermFleetRead |
| POST | `/api/v1/discovery/*` | PermFleetWrite |
| GET | `/api/v1/metrics` | PermFleetRead |
| GET | `/api/v1/events` | PermFleetRead |
| GET/POST | `/mcp` | Varies per tool (see mcp-tools.md) |

### Roles

Roles are assigned to users created via `/api/v1/users`. They map to permission sets:

| Role | Permissions |
|---|---|
| `admin` | PermAdmin (includes all via PermAdmin inheritance) |
| `operator` | PermFleetRead, PermFleetWrite, PermCommandExec, PermApprovalRead, PermApprovalWrite, PermAuditRead, PermWebhookManage |
| `viewer` | PermFleetRead, PermApprovalRead, PermAuditRead |

API keys carry explicit permission lists set at creation — they are not bound to roles.

### When Auth Is Disabled

If `LEGATOR_AUTH=false` (default), `authStore` and `sessionValidator` are nil. The `requirePermission()` middleware returns `true` for all requests without checking credentials. This is appropriate for local development only.

---

## 3. Request Body Size Limit

All `POST`, `PUT`, and `PATCH` endpoints enforce a **1 MB** body size limit. Requests with larger bodies are rejected with `413 Request Entity Too Large`.

---

## 4. Command Signing (HMAC-SHA256)

Every command dispatched from the control plane to a probe is signed. This prevents a man-in-the-middle from injecting arbitrary commands even if the WebSocket connection is intercepted.

### Key Derivation

A **master signing key** (32+ bytes, hex-encoded) is configured at startup (`LEGATOR_SIGNING_KEY`). A unique **per-probe signing key** is derived using HMAC-SHA256:

```
probe_key = HMAC-SHA256(master_key, "legator-probe-signing|<probe_id>")
```

Source: `internal/shared/signing/signing.go` — `DeriveProbeKey()`.

### Signing

Each command is signed over `requestID|JSON(payload)`:

```
signature = HMAC-SHA256(probe_key, "<requestID>|<json(payload)>")
```

The signature is transmitted with the command in the WebSocket message.

### Verification

The probe computes the expected signature independently and uses `hmac.Equal()` for constant-time comparison. Commands with invalid signatures are rejected without execution.

---

## 5. Federation Access Control

API keys and users can be granted **federation access scopes** to restrict which tenants/orgs/scopes they can read from the federation read model:

- `tenant:<id>` — restricts to a specific tenant
- `org:<id>` — restricts to a specific organization
- `scope:<id>` — restricts to a specific federation scope

Even if the requester provides no explicit `tenant_id` query param, the effective filter is automatically narrowed to their granted scope. Attempting to request data outside granted scope returns `403 Forbidden`.

This is enforced at both the REST layer (`GET /api/v1/federation/*`) and the MCP layer (`legator_federation_inventory`, `legator_federation_summary`).

---

## 6. Policy Engine

The policy engine provides a third independent security layer between authentication and probe execution.

### Policy Levels

| Level | Shell access | Read | Diagnostics | Writes | Process manipulation |
|---|---|---|---|---|---|
| `observe` | Allowlist only | ✅ | ❌ | ❌ | ❌ |
| `diagnose` | Extended allowlist | ✅ | ✅ | ❌ | ❌ |
| `remediate` | Full (with approval) | ✅ | ✅ | ✅ | With approval |

### Command Classification

Commands are classified by the policy engine as:
- **safe** — `observe`-level commands, dispatched immediately
- **elevated** — require `diagnose`+ level, may need approval
- **destructive** — always require human approval, queued in the approval queue

### Dual Enforcement

Policy is enforced at two independent points:
1. **Control plane** — before dispatch: checks policy level, command class, and capacity signals
2. **Probe** — on receipt: verifies command class against its local policy configuration

Even if control plane enforcement is bypassed, the probe refuses to execute disallowed commands.

### Approval Flow

Destructive commands go through:
1. Control plane receives `POST /api/v1/probes/{id}/command`
2. Policy engine classifies command as destructive → queues approval request
3. API returns `202 Accepted` with `approval_id`
4. Operator reviews and calls `POST /api/v1/approvals/{id}/decide` with `approved|denied`
5. On approval: command is dispatched with signature
6. On denial: command is discarded, audit event recorded

---

## 7. Registration Token Flow

New probes register using a one-time (or multi-use) token:

1. **Generate token:** `POST /api/v1/tokens` (requires FleetWrite)
   - Returns `token`, `expires`, and `install_command` (full curl|bash one-liner)
2. **Probe init:** Run the install script with `--server URL --token TOKEN`
   - Installs binary, creates systemd service, writes initial config
3. **Register:** Probe calls `POST /api/v1/register` with token + hostname/OS/arch
   - Token is consumed (single-use) or counted (multi-use)
   - Control plane generates `lgk_*` API key for the probe
   - Returns `probe_id` + `api_key` + initial `policy_id`
4. **Probe stores** the API key in its local config and uses it for all subsequent WebSocket connections

Token expiry defaults to 24 hours from creation. Multi-use tokens (`?multi_use=true`) can register unlimited probes. No-expiry tokens (`?no_expiry=true`) are for air-gapped environments.

---

## 8. Credential Sanitisation in Audit Logs

All audit events pass through `internal/shared/security/sanitize.go` before being written. The `Sanitize()` function strips sensitive values matching these patterns:

| Pattern | Example |
|---|---|
| `lgk_<64hex>` | Legator API keys |
| `bearer <token>` | Authorization header values |
| `Authorization: ...` | Full auth headers |
| JWT tokens (`eyJ...`) | Kubernetes SA tokens, OIDC tokens |
| Base64 tokens (40+ chars) | Generic long tokens |
| `api_key=<value>` | API key fields |
| `hvs.<hex>` | HashiCorp Vault tokens |
| `AKIA<16chars>` | AWS access key IDs |
| `aws_secret_access_key=...` | AWS secret keys |
| `password=<value>` | Password fields |
| `-----BEGIN * PRIVATE KEY-----` | Private key blocks |
| `client-certificate-data: ...` | Kubeconfig certs |
| `://<user>:<pass>@` | URL-embedded passwords |

Matched values are replaced with `[REDACTED]`. The prefix label (e.g. `"Authorization: "`) is preserved where possible for readability.

`SanitizeMap()` applies the same treatment to map keys that look like credentials (`password`, `secret`, `token`, `api_key`, `apikey`, `private_key`, `credential`).

---

## 9. OIDC Configuration

```bash
LEGATOR_OIDC_ENABLED=true
LEGATOR_OIDC_ISSUER=https://keycloak.example.com/realms/myrealm
LEGATOR_OIDC_CLIENT_ID=legator
LEGATOR_OIDC_CLIENT_SECRET=super-secret
LEGATOR_OIDC_REDIRECT_URL=https://legator.example.com/auth/oidc/callback
```

- Validates ID token signature against `<issuer>/.well-known/openid-configuration` JWKS endpoint
- Claims mapped to roles via `legator_role` claim or configurable claim name
- PKCE S256 enforced on all flows — no implicit flow supported

---

## 10. Probe Connection Security

- Probes connect to control plane via **WSS** (TLS WebSocket)
- Probe sends its `probe_id` + `api_key` in the initial handshake
- Control plane validates API key against stored hash
- Key mismatch → connection rejected
- Control plane never initiates outbound connections to probes

---

## 11. Network Security Recommendations

- Run control plane behind a TLS-terminating reverse proxy (Caddy, Nginx, Traefik)
- Restrict `/api/v1/auth/keys`, `/api/v1/users`, and `/api/v1/audit/purge` to management networks
- Use `LEGATOR_SIGNING_KEY=$(openssl rand -hex 32)` — never leave it empty in production
- Config file with secrets: `chmod 600 /etc/legator/config.yaml`
- Probe config with API key: `chmod 600 /etc/legator/probe.yaml` (root-owned)
- SQLite data directory: `chmod 700 /var/lib/legator`

---

## 12. Secrets Storage Summary

| Secret | Where | Format |
|---|---|---|
| Signing key | Config file / env | 32-byte hex (`openssl rand -hex 32`) |
| User passwords | SQLite `users` table | bcrypt (cost 10) |
| Probe API keys | SQLite `fleet` table | SHA-256 hashed |
| OIDC client secret | Config file / env | Plaintext (use env, `chmod 600` on config) |
| Registration tokens | In-memory | Plaintext (ephemeral, short-lived) |
