{{define "title"}}Fleet Chat — Legator{{end}}

{{define "header"}}
<div>
  <h1 class="page-title">Fleet Chat</h1>
  <span class="page-meta">Ask across all probes · v{{.Version}}</span>
</div>
<div class="right">
  <button class="btn" type="button" data-context-toggle aria-expanded="false" aria-controls="fleet-context-panel">Context</button>
  <span id="connection-status" class="tag"><span id="connection-dot" class="dot dot-pending"></span> <span id="connection-text">Connecting…</span></span>
</div>
{{end}}

{{define "content"}}
<section class="chat-shell">
  <section class="chat-container">
    <div id="message-list" class="chat-messages" aria-live="polite"></div>
    <div id="empty-state" class="empty-state">Ask the fleet anything.</div>
    <div id="typing" class="muted">Assistant is typing…</div>
  </section>
  <form id="chat-form" class="chat-input" autocomplete="off">
    <textarea id="chat-input" name="message" rows="1" placeholder="Ask fleet-wide questions or request checks..." maxlength="4000" autocomplete="off" required></textarea>
    <button id="send-btn" class="btn btn-primary" type="submit">Send</button>
  </form>
</section>

<div class="context-backdrop" id="context-backdrop" data-context-close></div>
<aside class="context-column panel" id="fleet-context-panel" aria-hidden="true">
  <div class="panel-header">
    <h2 class="panel-title">Fleet Context</h2>
    <button class="btn" type="button" data-context-close>Close</button>
  </div>
  <div class="feed" id="fleet-context">
    <div class="feed-item"><span class="muted">Total Probes</span> <span id="ctx-total">—</span></div>
    <div class="feed-item"><span class="muted">Online</span> <span id="ctx-online">—</span></div>
    <div class="feed-item"><span class="muted">Total CPUs</span> <span id="ctx-cpus">—</span></div>
    <div class="feed-item"><span class="muted">Total RAM</span> <span id="ctx-ram">—</span></div>
    <div id="fleet-probe-cards" class="feed"></div>
  </div>
</aside>
{{end}}

{{define "scripts"}}
<script>
(() => {
  const messageList = document.getElementById('message-list');
  const emptyState = document.getElementById('empty-state');
  const chatForm = document.getElementById('chat-form');
  const input = document.getElementById('chat-input');
  const sendButton = document.getElementById('send-btn');
  const typing = document.getElementById('typing');
  const connectionDot = document.getElementById('connection-dot');
  const connectionText = document.getElementById('connection-text');
  const cardsContainer = document.getElementById('fleet-probe-cards');
  const contextToggle = document.querySelector('[data-context-toggle]');
  const contextPanel = document.getElementById('fleet-context-panel');
  const contextCloseButtons = document.querySelectorAll('[data-context-close]');
  const maxInputHeight = 160;

  function setContextOpen(isOpen) {
    document.body.classList.toggle('context-open', isOpen);
    if (contextToggle) contextToggle.setAttribute('aria-expanded', String(isOpen));
    if (contextPanel) contextPanel.setAttribute('aria-hidden', String(!isOpen));
  }

  if (contextToggle) {
    contextToggle.addEventListener('click', () => {
      setContextOpen(!document.body.classList.contains('context-open'));
    });
  }
  contextCloseButtons.forEach((button) => button.addEventListener('click', () => setContextOpen(false)));

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && document.body.classList.contains('context-open')) {
      setContextOpen(false);
    }
  });

  function autoResizeInput() {
    input.style.height = 'auto';
    input.style.height = Math.min(input.scrollHeight, maxInputHeight) + 'px';
  }

  input.addEventListener('input', autoResizeInput);
  input.addEventListener('keydown', (event) => {
    if (event.key === 'Enter' && !event.shiftKey && !event.isComposing) {
      event.preventDefault();
      chatForm.requestSubmit();
    }
  });

  const knownMessageIds = new Set();
  let awaitingReply = false;
  let ws = null;
  let wsConnected = false;
  let reconnectTimeout = null;
  let pollTimer = null;
  const limit = 200;

  function toISODate(value) {
    if (!value) return '';
    const parsed = new Date(value);
    if (Number.isNaN(parsed.getTime())) return '';
    return parsed.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  }

  function updateConnection(connected) {
    wsConnected = connected;
    connectionDot.className = connected ? 'dot dot-online' : 'dot dot-offline';
    connectionText.textContent = connected ? 'Connected' : 'Disconnected';
  }

  function setTyping(isTyping) {
    typing.style.display = isTyping ? 'block' : 'none';
    input.disabled = isTyping;
    sendButton.disabled = isTyping;
  }

  function scrollToBottom() {
    messageList.scrollTop = messageList.scrollHeight;
  }

  function renderPlainText(container, text) {
    const line = document.createElement('div');
    line.className = 'chat-body';
    line.textContent = text;
    container.appendChild(line);
  }

  function renderContent(container, content) {
    if (!content) {
      renderPlainText(container, '');
      return;
    }

    const text = String(content);
    const codePattern = /```(?:[a-zA-Z0-9_+-]*)?\n?([\s\S]*?)```/g;
    let last = 0;
    let hasBlock = false;
    let match;

    while ((match = codePattern.exec(text)) !== null) {
      hasBlock = true;
      const before = text.slice(last, match.index);
      if (before.trim()) renderPlainText(container, before);

      const snippet = document.createElement('pre');
      snippet.className = 'chat-code';
      snippet.textContent = (match[1] || '').replace(/^\n/, '').trimRight();
      container.appendChild(snippet);

      last = match.index + match[0].length;
    }

    if (!hasBlock) {
      renderPlainText(container, text);
      return;
    }

    const remaining = text.slice(last);
    if (remaining.trim()) renderPlainText(container, remaining);
  }

  function renderMessage(message) {
    if (!message || !message.id || knownMessageIds.has(message.id)) return;
    knownMessageIds.add(message.id);
    emptyState.style.display = 'none';

    const role = message.role || 'system';
    const row = document.createElement('article');
    row.className = `msg-row ${role}`;

    const bubble = document.createElement('div');
    bubble.className = `msg msg-${role}`;

    const body = document.createElement('div');
    renderContent(body, message.content);
    bubble.appendChild(body);

    if (message.command_id) {
      const cmd = document.createElement('div');
      cmd.className = 'chat-meta';
      cmd.textContent = `command: ${message.command_id}`;
      bubble.appendChild(cmd);
    }

    if (message.timestamp) {
      const meta = document.createElement('div');
      meta.className = 'chat-meta';
      meta.textContent = toISODate(message.timestamp);
      bubble.appendChild(meta);
    }

    row.appendChild(bubble);
    messageList.appendChild(row);
    scrollToBottom();

    if (awaitingReply && role !== 'user') {
      awaitingReply = false;
      setTyping(false);
    }
  }

  async function loadHistory() {
    try {
      const resp = await fetch(`/api/v1/fleet/chat?limit=${limit}`, {
        method: 'GET',
        headers: { Accept: 'application/json' },
      });
      if (!resp.ok) return;

      const messages = await resp.json();
      if (!Array.isArray(messages)) return;
      messages.forEach((msg) => renderMessage(msg));
    } catch {}
  }

  function startPolling() {
    if (pollTimer) return;
    pollTimer = window.setInterval(() => {
      loadHistory();
    }, 3000);
    loadHistory();
  }

  function stopPolling() {
    if (!pollTimer) return;
    clearInterval(pollTimer);
    pollTimer = null;
  }

  function connectChatSocket() {
    if (ws) ws.close();

    const wsScheme = location.protocol === 'https:' ? 'wss:' : 'ws:';
    ws = new WebSocket(`${wsScheme}://${location.host}/ws/fleet-chat`);

    ws.onopen = () => {
      updateConnection(true);
      stopPolling();
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }
    };

    ws.onmessage = (event) => {
      if (!event.data) return;
      try {
        renderMessage(JSON.parse(event.data));
      } catch {}
    };

    ws.onclose = () => {
      updateConnection(false);
      startPolling();
      if (!reconnectTimeout) {
        reconnectTimeout = window.setTimeout(connectChatSocket, 3000);
      }
    };

    ws.onerror = () => {
      if (ws) ws.close();
    };
  }

  async function sendViaREST(content) {
    const response = await fetch('/api/v1/fleet/chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      body: JSON.stringify({ content }),
    });

    if (!response.ok) {
      throw new Error('failed to send message');
    }

    const assistantMessage = await response.json();
    renderMessage(assistantMessage);
    return assistantMessage;
  }

  chatForm.addEventListener('submit', async (event) => {
    event.preventDefault();
    if (awaitingReply) return;

    const content = input.value.trim();
    if (!content) return;

    input.value = '';
    autoResizeInput();
    awaitingReply = true;
    setTyping(true);

    renderMessage({
      id: `local-${Date.now()}`,
      role: 'user',
      content,
      timestamp: new Date().toISOString(),
    });

    if (wsConnected && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ content }));
      return;
    }

    try {
      await sendViaREST(content);
    } catch {
      awaitingReply = false;
      setTyping(false);
      renderMessage({
        id: `err-${Date.now()}`,
        role: 'system',
        content: 'Unable to send chat message. Check connection and try again.',
        timestamp: new Date().toISOString(),
      });
    }
  });

  function statusClass(status) {
    const s = (status || '').toLowerCase();
    if (s === 'online') return 'tag-online';
    if (s === 'offline') return 'tag-offline';
    if (s === 'degraded') return 'tag-degraded';
    return 'tag-pending';
  }

  async function loadFleetContext() {
    try {
      const resp = await fetch('/api/v1/fleet/inventory', { cache: 'no-store' });
      if (!resp.ok) return;
      const payload = await resp.json();
      const aggregates = payload.aggregates || {};
      const probes = Array.isArray(payload.probes) ? payload.probes : [];

      document.getElementById('ctx-total').textContent = aggregates.total_probes ?? probes.length;
      document.getElementById('ctx-online').textContent = aggregates.online ?? 0;
      document.getElementById('ctx-cpus').textContent = aggregates.total_cpus ?? '—';

      const ramBytes = aggregates.total_ram_bytes || 0;
      document.getElementById('ctx-ram').textContent = ramBytes > 0 ? Math.round(ramBytes / 1048576) + ' MB' : '—';

      cardsContainer.innerHTML = '';
      if (!probes.length) {
        const empty = document.createElement('p');
        empty.className = 'muted';
        empty.textContent = 'No probes available.';
        cardsContainer.appendChild(empty);
        return;
      }

      probes.forEach((probe) => {
        const card = document.createElement('a');
        card.className = 'panel';
        card.href = `/probe/${encodeURIComponent(probe.id)}/chat`;

        const name = probe.hostname || probe.id;
        const status = probe.status || 'unknown';
        const tags = Array.isArray(probe.tags) && probe.tags.length ? probe.tags.join(', ') : 'none';
        const ramMB = probe.ram_bytes ? Math.round(probe.ram_bytes / 1048576) : 0;

        card.innerHTML = `
          <div><strong>${name}</strong> <span class="tag ${statusClass(status)}">${status}</span></div>
          <div class="muted">${probe.id}</div>
          <div class="muted">${probe.os || 'unknown'}/${probe.arch || 'unknown'} · CPU ${probe.cpus || 0} · RAM ${ramMB} MB</div>
          <div class="muted">Tags: ${tags}</div>
        `;

        cardsContainer.appendChild(card);
      });
    } catch {}
  }

  setTyping(false);
  autoResizeInput();
  loadFleetContext();
  setInterval(loadFleetContext, 15000);
  loadHistory();
  connectChatSocket();
  startPolling();
})();
</script>
{{end}}
