# v1.0.0-alpha.5 Scope — "Demo-Ready"

Date: 2026-02-26
Owner: Marcus
Base: v1.0.0-alpha.4 (`272722b`)

## Theme

**Alpha.5 = you can install it, it enforces policy properly, and the UI tells the full story.**

Alpha.4 shipped multi-user RBAC, completing the core authentication/authorisation layer. Alpha.5 shifts focus to the end-to-end experience: a real install flow, defence-in-depth policy enforcement, visible audit/approval UIs, and documentation that lets someone who isn't us run the thing.

## Deliverables

### P5-1: Install Script → Real Probe Deployment (high)

**Goal:** The curl|bash one-liner from the spec actually works end-to-end.

**Scope:**
- Harden `install/install.sh`: OS/arch detection, download from GitHub Releases (or configurable base URL), SHA256 verification, `probe init` with registration token, systemd service installation
- Registration token lifecycle: single-use, configurable expiry (default 30min), HMAC-signed, consumed on use
- `POST /api/v1/tokens` returns a proper install command string
- Test the full flow: `curl|bash → binary download → register → heartbeat → command → response` on a clean environment
- `probe uninstall` cleans up properly (deregister + delete files + remove service)

**Acceptance:**
- Fresh install via one-liner on a Linux box registers probe and shows up in fleet view
- Token consumed, second use rejected
- `probe uninstall` leaves no trace
- e2e test covers token lifecycle

### P5-2: Probe-Side Policy Enforcement — Defence in Depth (high)

**Goal:** The probe independently refuses commands that exceed its local capability level, even if the control plane is compromised.

**Scope:**
- Policy config pushed to probe via WebSocket (`MsgPolicyUpdate`)
- Probe stores local policy (capability level + scope restrictions) in config
- Executor checks LOCAL policy before executing any command
- Command classification: observe/diagnose/remediate based on command content
- Rejection path: probe returns structured error (policy violation, required level, actual level)
- Control plane ALSO enforces policy (existing) — dual enforcement

**Acceptance:**
- Set probe to `observe` policy, send a write command (`touch /tmp/test`) → rejected at probe
- Set probe to `diagnose`, send `cat /etc/hostname` → allowed
- Set probe to `remediate`, send write command → allowed
- Policy update pushed from CP, probe picks it up within one heartbeat cycle
- e2e test: policy violation returns structured error with reason

### P5-3: Approval Queue + Audit Log Web Pages (medium)

**Goal:** Two new web pages that make the existing APIs visible.

**Scope:**
- `/approvals` page: pending approvals table, risk classification badge, approve/deny buttons, diff/detail expandable, auto-refresh via SSE
- `/audit` page: filterable audit log table (by probe, action type, user, time range), pagination, detail expand, export button (CSV/JSON)
- Wire to existing `GET /api/v1/approvals` and `GET /api/v1/audit` APIs
- Consistent with existing UI theme (dark, minimal)

**Acceptance:**
- Approval page shows pending items, approve/deny works from UI
- Audit page shows full log with working filters
- Pages accessible to authenticated users only
- No new API endpoints needed (existing APIs sufficient)

### P5-4: Getting-Started Documentation (medium)

**Goal:** A stranger can clone the repo and have a working control plane + probe in 15 minutes.

**Scope:**
- `README.md` rewrite: one-paragraph pitch, architecture diagram (ASCII), quick-start (3 steps), configuration reference, API overview
- `docs/getting-started.md`: step-by-step guide with examples
- `docs/architecture.md`: component diagram, data flow, security model summary
- Update `CHANGELOG.md` with alpha.1 through alpha.5 history

**Acceptance:**
- Someone unfamiliar with the codebase can follow README → running system
- Architecture diagram accurately reflects current system
- All configuration options documented

## Candidate Task Breakdown

| Task | Deliverable | Effort | Codex? |
|---|---|---|---|
| Install script hardening | P5-1 | Medium | Yes |
| Registration token lifecycle | P5-1 | Medium | Yes |
| Install flow e2e test | P5-1 | Small | Yes |
| Probe policy config store | P5-2 | Medium | Yes |
| Command classifier | P5-2 | Medium | Yes |
| Executor policy gate | P5-2 | Small | Yes |
| Policy push via WebSocket | P5-2 | Small | No (wiring) |
| Policy enforcement e2e test | P5-2 | Small | Yes |
| Approval queue web page | P5-3 | Medium | Yes |
| Audit log web page | P5-3 | Medium | Yes |
| README rewrite | P5-4 | Small | No (needs voice) |
| Getting-started guide | P5-4 | Small | No |
| Architecture doc | P5-4 | Small | No |

## Execution Order

1. P5-1 (install script) — highest impact, enables real demos
2. P5-2 (policy enforcement) — security differentiator, spec-critical
3. P5-3 (UI pages) — visual completeness
4. P5-4 (docs) — last because it documents the finished state

## Risks

- Install script testing needs a clean environment (container or fresh dir)
- Command classification heuristics may need tuning (start conservative)
- Approval queue UI depends on approval flow being exercised (need test data)

## CI Gate

- `go test ./...` passes
- `bash hack/e2e-test.sh` passes (29+ tests)
- `golangci-lint run ./...` clean
- Install script passes shellcheck
