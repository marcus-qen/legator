# v1.0.0-alpha.6 Scope — "Solid Foundation + SSO"

Date: 2026-02-26
Status: APPROVED by Keith
Base: main at `23e83b6` (post-alpha.5 fixes)

## Theme

**Alpha.6 = you can log in with Keycloak, the docs are great, and Marcus eats the dogfood.**

Alpha.5 completed the entire MVP spec. Alpha.6 hardens the foundation: OIDC integration for SSO, documentation that actually works cold, error handling for real-world usage, and daily dogfooding to surface rough edges.

## Deliverables

### P6-1: OIDC Authentication (high)

**Goal:** Optional OIDC login alongside existing local auth. "Sign in with Keycloak" on our deployment, simple username/password for everyone else.

**Design doc:** `projects/dev-lab/plans/reimaging/oidc-auth-design.md`

**Scope:**
- New package `internal/controlplane/oidc/` — Provider, Config, HandleLogin, HandleCallback
- Dependencies: `github.com/coreos/go-oidc/v3` + `golang.org/x/oauth2`
- Config: `oidc` block in `legator.json` + `LEGATOR_OIDC_*` env vars
- Login page: conditional "Sign in with {Provider}" button + divider + existing form
- Claim → user mapping: sub → ID, preferred_username → username, groups → role via configurable mapping
- Auto-create users on first OIDC login (configurable)
- Security: state param, nonce, PKCE (S256), ID token signature verification, no access token storage
- Create `legator` client in Keycloak dev-lab realm
- Deploy and verify SSO on legator.lab.k-dev.uk

**Acceptance:**
- Click "Sign in with Keycloak" → redirected → authenticate → back on fleet view with correct role
- Local auth still works when OIDC is enabled
- OIDC disabled (default) → login page unchanged (regression test)
- Audit log shows OIDC user identity

### P6-2: Documentation — All-In (high)

**Goal:** Someone who has never seen Legator can clone the repo, understand what it is, and have it running in 15 minutes. The docs should *sell*, not just explain.

**Scope:**
- `README.md` rewrite: one-paragraph pitch, ASCII architecture diagram, 3-step quick-start, feature highlights, screenshots
- `docs/getting-started.md`: step-by-step with examples (control plane setup, first probe, first chat, policy config)
- `docs/configuration.md`: every config option documented (JSON + env vars), including OIDC
- `docs/security.md`: auth model, command signing, defence-in-depth, OIDC, key rotation
- `CHANGELOG.md`: complete alpha.1 through alpha.6 history
- Verify getting-started guide cold (agent-browser: open docs, follow steps, confirm result)

**Acceptance:**
- A clean `git clone && make build` produces working binaries
- Getting-started guide tested end-to-end (using agent-browser for verification)
- All config options have documentation
- CHANGELOG is complete and accurate

### P6-3: Error Path Hardening (medium)

**Goal:** Legator handles real-world failure gracefully — not just the happy path.

**Scope:**
- LLM provider down/unreachable → graceful error in chat (not 500)
- Probe disconnects mid-command → command tracker timeout + client notification
- SQLite database locked → retry with backoff (WAL should prevent, but verify)
- Malformed WebSocket messages → logged + ignored (not crash)
- Invalid API requests → consistent JSON error responses with codes
- Login rate limiting (already exists — verify it works)
- Session fixation prevention (verify)

**Acceptance:**
- Kill LLM provider → chat returns "LLM unavailable" message
- Disconnect probe mid-command → command shows "timeout" status within 30s
- Fuzz test: send garbage to WebSocket → no panics
- All API error responses are JSON with consistent `{"error":"...", "code":"..."}` format

### P6-4: Dogfooding (ongoing)

**Goal:** Marcus uses Legator daily to manage principia. Every friction point becomes a bug or feature request.

**Scope:**
- Use Legator chat to check disk usage, service status, package versions, log queries
- File issues for every rough edge found
- Use agent-browser for periodic UI verification
- Track findings in daily logs

**Acceptance:**
- At least 10 real-world Legator interactions logged
- Issues filed for all discovered problems

---

## Candidate Task Breakdown

| Task | Deliverable | Effort | Codex? |
|---|---|---|---|
| OIDC provider package | P6-1 | Large | Yes |
| OIDC config parsing | P6-1 | Small | Yes |
| Login page OIDC button | P6-1 | Small | Yes |
| Claim → user mapping | P6-1 | Medium | Yes |
| OIDC unit tests (mock provider) | P6-1 | Medium | Yes |
| Keycloak client setup | P6-1 | Small | No (infra) |
| Deploy + verify SSO | P6-1 | Small | No (manual) |
| README rewrite | P6-2 | Medium | No (needs voice) |
| Getting-started guide | P6-2 | Medium | No |
| Configuration reference | P6-2 | Small | Partial |
| Security doc | P6-2 | Small | No |
| CHANGELOG | P6-2 | Small | No |
| Cold test of docs | P6-2 | Small | No (agent-browser) |
| Error path audit + fixes | P6-3 | Medium | Yes |
| Fuzz test for WebSocket | P6-3 | Small | Yes |
| API error consistency | P6-3 | Small | Yes |

## Execution Order

1. **P6-1** (OIDC) — biggest feature, Keith asked for it explicitly
2. **P6-3** (Error hardening) — interleave with OIDC testing
3. **P6-2** (Docs) — last because it documents the finished state including OIDC
4. **P6-4** (Dogfooding) — continuous throughout

## Dependencies

- P6-1 needs a Keycloak client created in the `dev-lab` realm
- P6-2 depends on P6-1 being complete (docs include OIDC)
- P6-3 is independent

## New Dependencies (Go modules)

```
github.com/coreos/go-oidc/v3  v3.x
golang.org/x/oauth2           v0.x
```

Both are standard, well-maintained, widely-used in the Go ecosystem.

## CI Gate

- `go test ./...` passes
- `bash hack/e2e-test.sh` passes (29+ tests)
- `golangci-lint run ./...` clean
- OIDC flow tested against Keycloak (manual verification)

## Risks

- Keycloak groups claim may need a custom protocol mapper (common gotcha)
- OIDC callback URL must be HTTPS (Caddy handles this)
- Token refresh not needed for MVP (sessions are Legator-managed, not provider-managed)
